<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
            闭包是个引用关系

            1.闭包的产生条件
                1.函数嵌套,必须有两个函数存在,并具有嵌套关系
                2.内部函数必须使用到外部函数的变量

                注意点:
                    1.内部函数不调用,也能产生闭包
                    2.闭包分为两种
                        有效闭包
                            外部函数会将内部函数返回出去,留作后续使用

                        无效闭包
                            外部函数没有将内部函数返回出去,该函数会被销毁,闭包只会出现一瞬间

            2.闭包的产生时机
                外部函数调用的时候
                内部函数声明的时候

            3.闭包的优点(用处)
                延长局部变量的生命周期
                    首先外部函数执行的时候会创建执行上下文(也就是变量对象)
                        当外部函数执行结束的时候,该执行上下文会被销毁,内部存储的变量也会被销毁

                        但是,由于内部函数正在使用其中的某个变量,所以该变量被闭包缓存下来了,
                            也就是本该死去,但是没死

                防止全局污染(可以实现js模块化)

            4.闭包的缺点(副作用)
                内部泄漏    本来可以使用更少的内存实现的功能,结果由于代码原因导致浪费更多的内存
                内存溢出    由于内存泄漏过多,导致内存爆炸了,所有程序无法正常运行,程序宕机

                内存泄漏可以接收,内存溢出无法接受

        */
       /*
        执行上下文
            执行上下文中,存储着变量对象以及this指向
                变量对象就是用于收集当前函数中声明的所有的变量
                    变量名会变为他的属性名,变量值会变为属性值

                其实这个变量对象就是所谓的作用域的产物
                    变量对象就是根据我们所知道的作用域规则产生的一个对象,它用于收集当前作用域中的所有变量

            创建时机
                当函数被调用的时候,会立即创建,并且放入执行栈中(俗称入栈)

            销毁时机
                当函数被调用结束之后,会立即销毁,并且弹出执行栈中(俗称出栈)
       */
      //    var a = 1;
      //    function fn(){
      //     console.log(a)
      //    }

      //------------------
    //   function wrap() {
    //     var a = 1;
    //     function inner() {
    //       console.log("inner", a);
    //     }

    //     return inner;
    //   }

    //   var fn = wrap();

      //-------------------------------------
    //   function wrap() {
    //     var a = 1;

    //     var inner = function () {
    //       console.log("inner", a);
    //     }

    //     return inner;
    //   }

    //   var fn = wrap();
    //   fn();

    //------------------------------
    // function fn(){
    //     var a = 1;
    //     a++;
    //     console.log(a)
    // }
    // fn();
    // fn();

    
    // function fn(){

    //     function inner(){
    //         console.log(a)
    //     }

    //     var a = 1;
    //     inner();
    // }

    // fn();

    //-----------------------------
    (function(){
        var a = 1;

        function getA(){
            console.log(a)
        }

        function addA(){
            a++;
            // console.log(a)
        }

        window.fns={
            getA,
            addA
        }
    })();

    fns.addA();
    fns.getA();

    // var a = 1;
    // a=2;
    </script>
  </body>
</html>
