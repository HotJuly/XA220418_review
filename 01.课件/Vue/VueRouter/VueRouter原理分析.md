# VueRouter

1. 请说说你对VueRouter
   1. 他是一个npm包
   2. 他是Vue的扩展插件
   3. 它可以实现单页面应用(SPA)
      1. 问题:请问什么是单页面应用?
         1. 页面是什么?
            1. 页面其实就是html文件
         2. 当前项目只存在一个html文件,但是可以通过DOM的增删改查方法,对页面上的结构进行操作,实现局部页面更新功能
   4. 问题:请问不使用VueRouter,单靠Vue能否实现单页面应用?
      1. 可以,他并不是一个必须使用的库
   5. 问题:请问我们是否有做过多页面应用?
      1. 做过,尚品汇的PC项目
      2. 只不过随着技术的变化,现在很多项目都是单页面项目

2. VueRouter提供给我们的东西
   1. 构造函数
      1. 通过VueRouter构造函数,可以获取路由器对象(router)
   2. 全局组件
      1. router-link
         1. 用处:生成a标签,当用户点击该标签,就会跳转到指定的路由地址
         2. **声明式导航的定义:通过标签的形式,引导用户进行跳转,这类操作成为声明式导航**
         3. **原理:**
            1. **默认生成一个a标签**
            2. **给该a标签绑定点击事件,在事件的回调函数中禁用a标签的默认行为**
            3. **并且调用编程式导航方法push或者replace实现路由跳转功能**
      2. router-view
         1. 用处:用于显示匹配当前路由路径的对应组件
         2. **其实核心原理就是使用到了响应式原理**
         3. **原理:**
            1. **首先获取到当前页面所处的路由地址**
            2. **并根据该路由地址,在routes数组中找到匹配的路由,并获取他的component属性值**
            3. **使用render方法,让router-view组件内部挂载流程2中获取到的component组件**
   3. 公共对象
      1. $router
         1. 是当前项目的路由器对象,用于管理所有的路由,并向外提供一些操作路由的API
         2. push
            1. **可以控制用户跳转到指定路由地址,跳转的时候,会保留上一个历史记录,并跳转到下一个路由,也就是说用户可以返回上一个路由**
            2. **编程式导航的定义:使用js的某些API,强行控制用户跳转,这类操作成为编程式导航**
            3. **原理:**
               1. **hash模式**
                  1. **其实push中只是调用了一个API,window.location.assign方法控制当前地址栏地址的变化(是一次伪跳转)**
               2. **history模式**
                  1. **其实push中,会调用window.history.pushState({},'','/home')方法控制当前地址栏地址的变化(是一次伪跳转)**
         3. replace
            1. **可以控制用户跳转到指定路由地址,跳转的时候,会覆盖上一个历史记录,并跳转到下一个路由,但是用户无法返回上一个路由**
            2. **原理:**
               1. **hash模式**
                  1. **其实replace中只是调用了一个API,window.location.replace('/#/about')方法控制当前地址栏地址的变化,而且会覆盖上一个历史记录**
               2. **history模式**
                  1. **其实push中,会调用window.history.replaceState({},'','/home')方法控制当前地址栏地址的变化(是一次伪跳转)**
      2. $route
         1. 是当前项目的路由对象,用于存储路由相关信息
         2. query
            1. 他是URL传参的一员
            2. 语法:"/home?username=xiaoming"
         3. params
            1. 他也是URL传参的一员
            2. 语法:"/home/1"
            3. 注意:必须在声明路由地址的时候,需要写好占位符
               1. path:"/home/:id"
         4. meta
            1. 他不是URL传参的一员
            2. 语法:在声明路由对象的时候,可以给对象添加meta属性,
               1. 那么该数据就可以在用户跳转到该路由的时候,通过$route.meta进行访问

3. 我们提供给VueRouter的东西
   1. 配置对象
      1. mode属性
         1. 属性值有两个
            1. hash值
               1. 可以开启hash模式的路由模式,特点就是路径中具有#/
               2. **原理:**
                  1. **通过给window绑定事件监视地址栏的修改,事件名:hashchange,在回调函数中可以通过window.location.hash获取到当前最新的地址**
                  2. **然后再将获取到的地址更新到响应式属性path中,从而导致router-view组件重新渲染**
               3. **优点:**
                  1. **兼容性特别好,兼容IE6+**
                  2. **浏览器知道#/home地址是前端解析的锚点功能,所以不会将该地址发送给服务器,也就是说无论在项目的哪个地址下,刷新当前页面,都是请求服务器根路径**
               4. **缺点:**
                  1. **丑是原罪,路径太丑了,甲方爸爸不肯用**
                  2. **由于地址中的#/路径跟锚点相同,会导致锚点功能无法正常使用**
            2. history值
               1. 可以开启history模式的路由模式,特点就是路径中具有/
               2. 原理:
                  1. **通过给window绑定事件监视地址栏的修改,事件名:popstate,在回调函数中可以通过window.location.pathname获取到当前最新的地址****
                  2. **然后再将获取到的地址更新到响应式属性path中,从而导致router-view组件重新渲染**
               3. **优点:**
                  1. **颜值就是正义,路径中没有#/**
                  2. **锚点功能正常**
               4. **缺点:**
                  1. **兼容性很差**
                  2. **需要后端服务器做出特殊配置才能正常使用**
                     1. **原因:因为/home该路径在浏览器眼里,会被误认为是后端接口,所以发送请求的时候会发送该请求路径**
                     2. **流程:**
                        1. **当用户在某个路由地址下刷新浏览器的时候**
                        2. **浏览器会将当前的地址栏中的路径发送给服务器**
                           1. **此时/home本身是前端路由,但是被错误识别为后端路由**
                        3. **服务器接收到/home请求,服务器没有该接口,就会返回404响应**
                        4. **那么最终浏览器就无法正常显示页面**
                     3. **面试题:history模式,在项目上线的时候需要做什么配置?**
                        1. **要求后端将自己所有没有的接口,统一返回index.html文件(返回当前项目的html文件)**
                        2. **流程:**
                           1. **当用户在某个路由地址下刷新浏览器的时候**
                           2. **浏览器会将当前的地址栏中的路径发送给服务器**
                              1. **此时/home本身是前端路由,但是被错误识别为后端路由**
                           3. **服务器接收到/home请求,服务器没有该接口,但是会返回index.html文件**
                           4. **浏览器接收到index.html文件,开始解析该文件**
                           5. **解析过程中发现,需要请求js文件**
                           6. **服务器接收到请求,会返回该js文件**
                           7. **浏览器接收到js文件,会自动执行内部代码**
                           8. **内部代码中的VueRouter代码就会立即执行,自动获取地址栏中的前端路由/home,找到对应的路由组件,实现渲染该组件的效果**
      2. routes属性
         1. 属性值类型:routerObj[]
         2. routeObj对象的重要属性
            1. path属性
               1. 代表当前路由的路由地址
            2. component属性
               1. 如果当前路径中的地址与自己的path相同,那么就展示对应的路由组件
         3. 扩展:只有注册的路由组件,才能够访问使用

4. 导航守卫(又称为路由守卫)

   1. 一共分为三大类,共7个

      1. 其实导航守卫就像是新增的7个生命周期

   2. 全局守卫

      1. 全局前置守卫(beforeEach)

         1. 在路由跳转之前执行

         2. ```javascript
            router.beforeEach((to, from, next) => {
            	//to->想跳转到哪个路由
              	//from->从哪个路由跳转过来
                //next->放行
            	//next()->不穿任何参数,直接调用,就是放行
                //next(false)->不允许跳转,从哪来回哪去
                //next("/login")->即不允许前进,也不允许后退,会被强制带到某个路由
            })
            ```

            ​

      2. 全局解析守卫(beforeResolve)

         1. 当组件代码解析结束之后执行

      3. 全局后置守卫(afterEach)

         1. 在跳转到达目的地之后才执行

   3. 路由独享守卫

      1. 进入该路由之前会触发

      2. ```javascript
         const router = new VueRouter({
           routes: [
             {
               path: '/foo',
               component: Foo,
               beforeEnter: (to, from, next) => {
                 // ...
               }
             }
           ]
         })
         ```

         ​

   4. 组件内置守卫

      1. 组件进入守卫

         1. 进入该组件之前会触发

         2. ```javascript
            //写在组件的配置对象身上,与生命周期函数同级
            const Foo = {
              template: `...`,
              beforeRouteEnter(to, from, next) {
                // 在渲染该组件的对应路由被 confirm 前调用
                // 不！能！获取组件实例 `this`
                // 因为当守卫执行前，组件实例还没被创建
              },
              beforeRouteUpdate(to, from, next) {
                // 在当前路由改变，但是该组件被复用时调用
                // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
                // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
                // 可以访问组件实例 `this`
              },
              beforeRouteLeave(to, from, next) {
                // 导航离开该组件的对应路由时调用
                // 可以访问组件实例 `this`
              }
            }
            ```

            ​

      2. 组件更新守卫

         1. 当组件被复用的时候会触发

      3. 组件离开守卫

         1. 当要从该组件离开之前执行