1.props
	使用场景:父子组件通信
	
	父传子流程:
		1.父组件通过在子组件的标签上,添加标签属性,向子组件传递数据
		2.子组件需要在自己的配置对象中,添加props配置属性,声明需要接收的标签属性名

		父组件传给子组件的是数据

	子传父流程:
		1.父组件通过在子组件的标签上,添加标签属性,向子组件传递函数
			注意:函数必须生命在父组件的methods中才可以
				因为methods中声明的方法,this一定是当前组件的实例对象
					methods中的方法,全部都会被Vue使用bind强行执行this指向,后续无法修改

		2.子组件需要在自己的配置对象中,添加props配置属性,声明需要接收的标签属性名

		3.子组件调用传递下来的函数,并向内部传入参数

		4.父组件接收到数据之后,可以更新到自己的data中

		父组件传给子组件的是函数

2.provide/inject
	使用场景:祖孙组件通信
	流程:
		1.祖先组件在自己的配置对象中,书写provide配置属性,并将需要暴露的数据放在内部
		2.后代组件在自己的配置对象中,书写inject配置属性,用于接收祖先组件暴露出来的数据

	注意点:
		1.如果想要将当前组件的data或者props等数据暴露出去,provide必须写成函数形式才能暴露
			因为如果是对象的话,那么provide内部的值确定的时候,组件还没有创建处理对象,时间不对,无法使用this

		2.provide 和 inject 绑定并不是可响应的
			问题:如何将provide暴露出去的数据变成响应式的?
				方法一 -> 先在data中创建一个响应式的对象,在用provide暴露出去
				方法二 -> 使用Vue.observable将一个普通对象变成响应式对象,在暴露出去

		3.如果存在多个provide,那么会从内向外查找

3.自定义事件
	v-model
		对input标签使用
			1.将data中的某个状态数据,作为input框的默认值进行显示
				<input type="text" :value="msg">
			2.当input框的内容发生修改的时候,会同步修改data中对应的状态数据
				<input type="text" :value="msg" @input="(event)=>msg=event.target.value">

		对组件标签使用
			1.父组件通过添加标签属性的形式,给子组件传递数据(默认属性名:value)
    				<HelloWorld  :value="msg"/>
			2.父组件给子组件绑定自定义事件,子组件可以触发该自定义事件,传入参数,实现修改父组件数据的效果(默认事件名:input)
    				<HelloWorld  :value="msg" @input="(data)=>msg=data"/>

		扩展点:
			通过给子组件书写model配置属性,就可以自定义当前传下来的标签属性名和事件名


4.找到对应组件的实例对象
	$parent->获取到父组件的实例对象
	$root->获取到当前组件树中的根组件实例对象,其实就是main.js中new Vue的那个
	$children->获取到由子组件实例对象组成的数组
		注意点:
			1.该数组的排列顺序,不能保证和组件的书写顺序相同(因为有可能出现异步组件)
			2.该数组没有响应式效果,不要想着去操作他的下标,没用

	$refs->他是一个对象,内部会存放页面上相关的一些东西
		需要配合ref标签属性使用
			如果对原生html标签使用ref,可以得到真实DOM
			如果对组件标签使用ref,可以得到组件实例对象

5.$attrs和$listeners
	$attrs->收集props没有接收的标签属性,最终组成一个对象
		算是一个捡垃圾的

	$listeners->收集当前组件身上所有的自定义事件,最终组成一个对象

	扩展:
		1.v-bind可以接收一个对象,会将对象中所有的属性名作为标签属性,属性值作为标签属性值进行使用
			虽然v-bind配合$attrs属性有很好的效果,但是v-bind不是非得和他配合,v-bind要的只是一个对象
		2.v-on可以接收一个对象,对象的属性名会作为事件名称,属性值会作为事件的回调函数
            			<el-button v-bind="$attrs" v-on="$listeners">添加</el-button>

