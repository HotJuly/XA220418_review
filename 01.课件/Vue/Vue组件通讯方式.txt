1.props
	使用场景:父子组件通信
	
	父传子流程:
		1.父组件通过在子组件的标签上,添加标签属性,向子组件传递数据
		2.子组件需要在自己的配置对象中,添加props配置属性,声明需要接收的标签属性名

		父组件传给子组件的是数据

	子传父流程:
		1.父组件通过在子组件的标签上,添加标签属性,向子组件传递函数
			注意:函数必须生命在父组件的methods中才可以
				因为methods中声明的方法,this一定是当前组件的实例对象
					methods中的方法,全部都会被Vue使用bind强行执行this指向,后续无法修改

		2.子组件需要在自己的配置对象中,添加props配置属性,声明需要接收的标签属性名

		3.子组件调用传递下来的函数,并向内部传入参数

		4.父组件接收到数据之后,可以更新到自己的data中

		父组件传给子组件的是函数

2.provide/inject
	使用场景:祖孙组件通信
	流程:
		1.祖先组件在自己的配置对象中,书写provide配置属性,并将需要暴露的数据放在内部
		2.后代组件在自己的配置对象中,书写inject配置属性,用于接收祖先组件暴露出来的数据

	注意点:
		1.如果想要将当前组件的data或者props等数据暴露出去,provide必须写成函数形式才能暴露
			因为如果是对象的话,那么provide内部的值确定的时候,组件还没有创建处理对象,时间不对,无法使用this

		2.provide 和 inject 绑定并不是可响应的
			问题:如何将provide暴露出去的数据变成响应式的?
				方法一 -> 先在data中创建一个响应式的对象,在用provide暴露出去
				方法二 -> 使用Vue.observable将一个普通对象变成响应式对象,在暴露出去

		3.如果存在多个provide,那么会从内向外查找

3.自定义事件

	vm.$on(也可以使用@符绑定自定义事件)
		给某个组件实例对象,绑定自定义事件
	vm.$once
		给某个组件实例对象,绑定自定义事件,但是只能触发一次
	vm.$emit
		触发某个组件实例对象身上的某类自定义事件的
	vm.$off
		用于解绑某个组件实例对象身上的自定义事件

	v-model
		对input标签使用
			1.将data中的某个状态数据,作为input框的默认值进行显示
				<input type="text" :value="msg">
			2.当input框的内容发生修改的时候,会同步修改data中对应的状态数据
				<input type="text" :value="msg" @input="(event)=>msg=event.target.value">

		对组件标签使用
			1.父组件通过添加标签属性的形式,给子组件传递数据(默认属性名:value)
    				<HelloWorld  :value="msg"/>
			2.父组件给子组件绑定自定义事件,子组件可以触发该自定义事件,传入参数,实现修改父组件数据的效果(默认事件名:input)
    				<HelloWorld  :value="msg" @input="(data)=>msg=data"/>

		扩展点:
			通过给子组件书写model配置属性,就可以自定义当前传下来的标签属性名和事件名

	.sync修饰符
		1.父组件通过添加标签属性的形式,给子组件传递数据(属性名称可以自定义)
			<HelloWorld :msg="msg"/>

		2.父组件给子组件绑定自定义事件,子组件可以触发该自定义事件,传入参数,实现修改父组件数据的效果(事件名称: update:属性名)
   			 <HelloWorld :msg="msg" @update:msg="(data)=>msg=data"/>

		注意:在Vue3中,v-model和.sync二合一了,只剩下v-model的外壳,内部原理是.sync原理

	全局事件总线
		角色
			订阅者	->	想要接收数据的人
			发布者	->	想要发送数据的人

		操作
			订阅
			发布
			解绑

		约束
			1.订阅者和发布者必须同时存在
			2.订阅必须在发布之前
		
		流程:
			1.在Vue的原型对象身上创建事件总线对象	
				Vue.prototype.$bus = new Vue();
				注意:
					1.属性名不一定非要是$bus,可以任意取名
					2.事件对象必须是一个Vue实例对象,否则无法使用$on和$emit

			2.在需要接收数据的组件上,订阅消息
    				this.$bus.$on('abc',(data)=>{
      					console.log('abc',data)
   				 })

			3.在需要发送数据的组件上,发布消息
   				 this.$bus.$emit('abc',999)
			
			4.当不要再次传递数据的时候,可以解绑该自定义事件
				this.$bus.$off('abc')
		

4.找到对应组件的实例对象
	$parent->获取到父组件的实例对象
	$root->获取到当前组件树中的根组件实例对象,其实就是main.js中new Vue的那个
	$children->获取到由子组件实例对象组成的数组
		注意点:
			1.该数组的排列顺序,不能保证和组件的书写顺序相同(因为有可能出现异步组件)
			2.该数组没有响应式效果,不要想着去操作他的下标,没用

	$refs->他是一个对象,内部会存放页面上相关的一些东西
		需要配合ref标签属性使用
			如果对原生html标签使用ref,可以得到真实DOM
			如果对组件标签使用ref,可以得到组件实例对象

5.$attrs和$listeners
	$attrs->收集props没有接收的标签属性,最终组成一个对象
		算是一个捡垃圾的

	$listeners->收集当前组件身上所有的自定义事件,最终组成一个对象

	扩展:
		1.v-bind可以接收一个对象,会将对象中所有的属性名作为标签属性,属性值作为标签属性值进行使用
			虽然v-bind配合$attrs属性有很好的效果,但是v-bind不是非得和他配合,v-bind要的只是一个对象
		2.v-on可以接收一个对象,对象的属性名会作为事件名称,属性值会作为事件的回调函数
            			<el-button v-bind="$attrs" v-on="$listeners">添加</el-button>


6.插槽
	一共分为三种
	默认插槽
		1.父组件在子组件的标签中,传入一段页面结构
		2.子组件在自己的template中,书写slot组件,用于显示这段插槽结果

	具名插槽
		1.父组件在子组件的标签中,传入一段页面结构
			在传递结构的使用,需要使用v-slot指令给当前插槽取别名

		2.子组件在自己的template中,书写slot组件,用于显示这段插槽结果
			在slot组件身上,需要额外书写一个name属性,用于告知显示哪个具名插槽

	作用域插槽
		1.父组件在子组件的标签中,传入一段页面结构
			在传递结构的使用,需要使用v-slot指令给当前插槽取别名

		2.子组件在自己的template中,书写slot组件,用于显示这段插槽结果
			在slot组件身上,需要额外书写一个name属性,用于告知显示哪个具名插槽

		3.子组件给slot组件添加标签属性,实现传递数据效果

		4.父组件在书写插槽的时候,需要声明变量接收传递过来的数据,数据是一个对象
			该对象相当于是一个props对象,它内部存储这slot组件身上所有的标签属性
			最终在插槽结构中,可以使用该对象中的数据

		所有的插槽都是父向子传参,
			即便是作用域插槽,看起来是子向父传参,但是原理中还是父向子
				因为HelloWorld组件会将数据通过标签属性传递给slot组件,slot组件会将数据传递给插槽结构进行显示
					而插槽结果也是显示在slot组件内部的

	插槽是将一段结构传递给另外一个组件

7.VueRouter路由传参

8.Vuex
