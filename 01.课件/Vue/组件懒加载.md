# 组件懒加载相关

1. 前言
   1. 我们没有使用组件懒加载的情况,写完Vue项目,会执行npm run build进行生产环境打包代码,此时会得到一个dist文件夹,该文件夹中会具有以下文件:
      1. index.html
      2. index.js
      3. 注意:
         1. 如果图片大小超过2MB,那么这些图片会被存放在static文件夹中,单独存放
         2. 如果图片大小小于2MB,那么这些图片就会被使用base64格式进行编码,最终直接填写在img标签的src中
      4. 假设当前项目一共具有10个组件文件,那么也就是说绝大多的代码都存放于index.js中
         1. 如果每个组件文件大小1MB,那么index.js文件大小应该是1*10=10MB
         2. 用户只是请求了当前的官网,暂时只看首页,但是由于index.js文件中存放的是所有的js代码,导致用户不得不一次得到所有内容,**结果延长请求花费的时间,首页白屏时间更久,页面渲染速度变慢**
2. 模块化语法
   1. import Home from '@/components/Home.vue'
      1. 这种引入语法,俗称静态引入
      2. 这种语法,在项目上线的时候,以生产环境打包,该语法会消失,被对应的文件内容替代
      3. 最终导致,所有的文件代码都汇总到了入口文件中,所有组件的代码变成1个js文件
   2. import('@/components/Home.vue')
      1. 这种引入语法,俗称动态引入
      2. 这种语法,在项目上线之后,依旧存在于代码中,该语法不会消失,当代码执行的时候,才会立即请求该资源
      3. webpack遇到该语法,会自动将引入的文件切割为一个单独的文件
3. 组件懒加载的优点
   1. 做了什么?
      1. 使用模块语法的动态引入语法,引入除了首页以外的9个组件代码
      2. 那么index.js中只会具有核心代码以及首页组件的代码,而其余9个组件会变成9个单独的js文件,那么此时dist文件夹中,拥有的文件数量是1+1+9=11个
         1. index.html
         2. index.js
         3. 其余9个组件的js文件
         4. 所以此时index.js文件中只有首页的代码,文件大小是1MB
   2. 最终得到的效果
      1. 用户请求当前网站,获取到index.js文件,该文件中由于组件懒加载之后,体积变小,**导致页面请求的资源变少,占用的网速变小,代码解析时间变短,最终导致首页白屏时间变短,页面渲染速度加快**
4. 组件懒加载的缺点
   1. 由于首次请求的index.js中,没有其余页面的代码,所以当用户切换页面显示的时候,后续页面都需要发送请求,获取对应的代码文件来进行显示,也就是说缺点**就是后续页面都要发送请求,展示过程需要等到网络响应,最终后续页面的显示速度都变慢**
5. 组件预加载
   1. 趁着用户不注意,偷偷的请求后续可能需要用到的组件代码
   2. 优点:**当用户需要切换页面的时候,由于已经提前加载好了对应代码,用户的切换页面操作属于内存级别操作,不需要等到网络请求时间,后续页面展示速度也变快**
   3. 缺点:**浪费流量(可能请求的资源,用户根本用户到)**
   4. 原理:**其实就是用过创建script标签,给script添加src属性,他就会自动请求对应的文件代码**
      1. **Vue脚手架中,自带该功能**